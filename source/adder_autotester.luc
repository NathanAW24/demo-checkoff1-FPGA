module adder_autotester (
    input clk,  // clock
    input rst,  // reset
    input button_next_test_case[1], // down btn press 
    input button_speed_through[1], // up button press 
    input button_reset[1],
    input inv[1],
    output current_test_case[5],
    output current_statusPF[2],
    output out[16]
  ) {
  
  // register to store the current test case number 
  dff current_test_case_register[5](#INIT(b00000),.clk(clk) , .rst(rst));
  
  // register to store the current out value in each test cse 
  dff reg_current_out[16](.clk(clk) , .rst(rst)); // ADDED BY ANSAR TO FIX OUTPUT ON 7 SEGMENT
  
  //register tot store current test status 
  dff reg_current_statusPF[2](#INIT(b00),.clk(clk) , .rst(rst));
  
  // register to set the tester on speed through tests all
  // test cases at once no waiting for button 
  dff speed_through[1](#INIT(b0), .clk(clk) , .rst(rst));
  
  // Declare the fsm states
  fsm state (.clk(clk), .rst(rst)) = {IDLE, TESTING, PASS};
  fsm track_failure (.clk(clk), .rst(rst)) = {NULL, FAIL_BEFORE};
  
  //import alu
  alu alu_unit; 

  always {
    // Declare initial values
    //current_test_case = 5b0; removed log 1
    alu_unit.a = 16b0;
    alu_unit.b = 16b0;
    alu_unit.inv = inv ; 
    alu_unit.alufn_signal = 6b0; // default adder 
    state.d = state.IDLE;
    track_failure.d = track_failure.NULL; // ADDED BY ANSAR TO FIX RESET BUTTON
    
    if(button_speed_through){
      speed_through.d = b1; 
      }
    
    case(state.q){
      state.IDLE:
        if(speed_through.q){
          state.d = state.TESTING; 
          current_test_case_register.d = current_test_case_register.q + b00001;
        }
        if(button_next_test_case){
          state.d = state.TESTING; 
          current_test_case_register.d = current_test_case_register.q + b00001 ;
          }
        if(button_reset){ // ADDED BY ANSAR TO FIX RESET BUTTON
          state.d = state.IDLE; // ADDED BY ANSAR TO FIX RESET BUTTON
          current_test_case_register.d = 5b0; // ADDED BY ANSAR TO FIX RESET BUTTON
          reg_current_out.d = 16b0;// change output register back to 0
          reg_current_statusPF.d = 2b00; // register status to 0
        }
        
      state.TESTING: 
        case(current_test_case_register.q){
          // ADD: 0 + 0
          b00001:
            alu_unit.a = 16h0000;
            alu_unit.b= 16h0000;
            alu_unit.alufn_signal = 6b0;
            current_test_case = current_test_case_register.q;
            reg_current_statusPF.d = b01;
            reg_current_out.d = alu_unit.out; 

       
            if (alu_unit.out != 16h0000){
              track_failure.d = track_failure.FAIL_BEFORE;
              reg_current_statusPF.d = b10;
  
            }
            state.d =state.IDLE;  
            
          // ADD: pos + pos with overflow
          b00010:
            alu_unit.a = 16h8001;
            alu_unit.b= 16h8000;
            alu_unit.alufn_signal = 6b0;
            reg_current_statusPF.d = b01;
            current_test_case = current_test_case_register.q;
            reg_current_out.d = alu_unit.out; 

                  
            if (alu_unit.out != 16h0001){
              track_failure.d = track_failure.FAIL_BEFORE;
              reg_current_statusPF.d = b10;
  
            }
            state.d =state.IDLE;  
            
            
          // ADD: pos + pos with NO overflow
          b00011:
            alu_unit.a = 16h0001;
            alu_unit.b= 16h0001;
            alu_unit.alufn_signal = 6b0;
            reg_current_statusPF.d = b01;            
            current_test_case = current_test_case_register.q;
            reg_current_out.d = alu_unit.out; 
                 
            
            if (alu_unit.out != 16h0002){
              track_failure.d = track_failure.FAIL_BEFORE;
              reg_current_statusPF.d = b10;
  
            }
            state.d =state.IDLE; 
            
            
            
          // ADD: pos + neg with overflow
          b00100:
            alu_unit.a = 16h0004;
            alu_unit.b= 16hFFFF;
            alu_unit.alufn_signal = 6b0;
            reg_current_statusPF.d = b01;
            current_test_case = current_test_case_register.q;
            reg_current_out.d = alu_unit.out; 
            
                    
            if (alu_unit.out != 16h0003){
              track_failure.d = track_failure.FAIL_BEFORE;
              reg_current_statusPF.d = b10;
  
            }
            state.d =state.IDLE; 
            
          // ADD: pos + neg with NO overflow
          b00101:
            alu_unit.a = 16h0001;
            alu_unit.b= 16hF000;
            alu_unit.alufn_signal = 6b0;
            reg_current_statusPF.d = b01;
            current_test_case = current_test_case_register.q;
            reg_current_out.d = alu_unit.out; 

                                
            if (alu_unit.out != 16hF001){
              track_failure.d = track_failure.FAIL_BEFORE;
              reg_current_statusPF.d = b10;
  
            }
            state.d =state.IDLE; 
            
            
          // SUB: 0 - 0
          b00110:
            alu_unit.a = 16h0000;
            alu_unit.b= 16h0000;
            alu_unit.alufn_signal = 6b000001;
            reg_current_statusPF.d = b01;
            current_test_case = current_test_case_register.q;
            reg_current_out.d = alu_unit.out; 

                               
            if (alu_unit.out != 16h0000){
              track_failure.d = track_failure.FAIL_BEFORE;
              reg_current_statusPF.d = b10;
  
            }
            state.d =state.IDLE; 
            
            
            
            
          // SUB: pos - pos with NO overflow
          b00111:
            alu_unit.a = 16h0002;
            alu_unit.b= 16h0001;
            alu_unit.alufn_signal = 6b000001;
            reg_current_statusPF.d = b01;
            current_test_case = current_test_case_register.q;
            reg_current_out.d = alu_unit.out; 

                    
            if (alu_unit.out != 16h0001){
              track_failure.d = track_failure.FAIL_BEFORE;
              reg_current_statusPF.d = b10;
  
            }
            state.d =state.IDLE;    
            
            
          // SUB: pos - neg with overflow
          b01000:
            alu_unit.a = 16h7FFF;
            alu_unit.b= 16h8001;
            alu_unit.alufn_signal = 6b000001;
            reg_current_statusPF.d = b01;
            current_test_case = current_test_case_register.q;
            reg_current_out.d = alu_unit.out; 
                    
            if (alu_unit.out != 16hFFFE){
              track_failure.d = track_failure.FAIL_BEFORE;
              reg_current_statusPF.d = b10;
  
            }
            state.d =state.IDLE;       
            
            
            
          // SUB: pos - neg with overflow
          b01001:
            alu_unit.a = 16h0001;
            alu_unit.b= 16hFFFF;
            alu_unit.alufn_signal = 6b000001;
            reg_current_statusPF.d = b01;
            current_test_case = current_test_case_register.q;
            reg_current_out.d = alu_unit.out; 
                    
            if (alu_unit.out != 16h0002){
              track_failure.d = track_failure.FAIL_BEFORE;
              reg_current_statusPF.d = b10;
  
            }
            state.d =state.IDLE;        
            
          // SUB: neg - pos with overflow
          b01010:
            alu_unit.a = 16h8000;
            alu_unit.b= 16h0001;
            alu_unit.alufn_signal = 6b000001;
            reg_current_statusPF.d = b01;
            current_test_case = current_test_case_register.q;
            reg_current_out.d = alu_unit.out; 
                    
            if (alu_unit.out != 16h7FFF){
              track_failure.d = track_failure.FAIL_BEFORE;
              reg_current_statusPF.d = b10;
  
            }
            state.d =state.IDLE;      
            
            
            
          // SUB: neg - pos with NO overflow
          b01011:
            alu_unit.a = 16hFFFF;
            alu_unit.b= 16h0001;
            alu_unit.alufn_signal = 6b000001;
            reg_current_statusPF.d = b01;
            current_test_case = current_test_case_register.q;
            reg_current_out.d = alu_unit.out; 
                    
            if (alu_unit.out != 16hFFFE){
              track_failure.d = track_failure.FAIL_BEFORE;
              reg_current_statusPF.d = b10;
  
            }
            state.d =state.IDLE;      
            
            
            
          // SUB: neg - pos with NO overflow
          b01100:
            alu_unit.a = 16hFFFF;
            alu_unit.b= 16hFFFF;
            alu_unit.alufn_signal = 6b000001;
            reg_current_statusPF.d = b01;
            current_test_case = current_test_case_register.q;
            reg_current_out.d = alu_unit.out; 
                    
            if (alu_unit.out != 16h0000){
              track_failure.d = track_failure.FAIL_BEFORE;
              reg_current_statusPF.d = b10;
  
            }
            state.d =state.PASS; 
            
            
          // ***********************************************
          // TEST PASSED! After everything above run alr
          default:
            current_test_case_register.d = b01101;
            state.d = state.PASS;
           
        }
      state.PASS:
        if(track_failure.q == track_failure.FAIL_BEFORE){
          reg_current_statusPF.d = b10 ;
          }else{
            reg_current_statusPF.d = b11;
          }
        if(button_reset){
            state.d = state.IDLE;
            current_test_case_register.d = 5b0; 
            reg_current_out.d = 16b0; 
            reg_current_statusPF.d = 2b00;
          }
      }
    //used to display on 7 seg display 
    out = reg_current_out.q ; // ADDED BY ANSAR TO FIX OUTPUT ON 7 SEGMENT
    current_test_case = current_test_case_register.q;
    current_statusPF = reg_current_statusPF.q;
  }
}